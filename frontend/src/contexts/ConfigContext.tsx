/**
 * ============================================================================
 * CONFIG CONTEXT - Centralized Configuration Management
 * ============================================================================
 *
 * PURPOSE:
 * Loads config.json once on app startup and provides it to all components.
 * This allows the GitHub Action to inject branding, tiers, and settings
 * without modifying component code.
 *
 * ARCHITECTURE:
 * 1. ConfigProvider wraps the entire app (in App.tsx)
 * 2. Fetches /config.json on mount (public folder)
 * 3. All components use useConfig() hook to access config
 * 4. No prop drilling, clean separation of concerns
 *
 * CONFIG STRUCTURE (from KV data):
 * {
 *   branding: {
 *     appName: "We might make it work",
 *     logoUrl: "https://...",
 *     primaryColor: "#FFD700",
 *     valueProp: "i am going to be impressed",
 *     description: "Claude read this to me...",
 *     heroImageUrl: "https://..."
 *   },
 *   product: {
 *     name: "i love claude code"
 *   },
 *   tiers: [...],  // Fetched from API, not used directly here
 *   apiUrl: "https://preview-{userId}-api.workers.dev",
 *   clerkPublishableKey: "pk_test_..."
 * }
 *
 * HOW TO EXTEND:
 * 1. Add new fields to Config interface below
 * 2. Update config.json structure in GitHub Action
 * 3. Components automatically get new fields via useConfig()
 *
 * ============================================================================
 */

import React, { createContext, useContext, useEffect, useState } from 'react';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * Branding configuration (from Styling page in fact-saas)
 * These values customize the look and feel of the entire app
 */
interface BrandingConfig {
  appName: string;              // "MyApp" - Shows in nav, footer
  logoUrl?: string;             // Optional logo image URL
  primaryColor: string;         // "#FFD700" - Main brand color for buttons, links
  valueProp: string;            // "Deploy Your SaaS in 5 Minutes" - Hero headline
  description?: string;         // Optional longer description
  heroImageUrl?: string;        // Optional hero section image
}

/**
 * Product configuration (from Configure page in fact-saas)
 */
interface ProductConfig {
  name: string;                 // "My SaaS Product" - Internal product name
}

/**
 * Tier configuration (processed by GitHub Action)
 * Note: Frontend fetches tiers from API, but this is here for reference
 */
interface TierConfig {
  id: string;                   // "free", "pro", "enterprise"
  name: string;                 // "Free", "Pro", "Enterprise"
  price: number;                // 0, 29, 99
  limit: number | 'unlimited';  // 7, 100, 'unlimited'
  features: string[];           // ["Feature 1", "Feature 2"]
  popular: boolean;             // Show "Popular" badge
  stripePriceId: string | null; // Stripe price ID (null for free tier)
}

/**
 * Complete configuration object
 * Generated by GitHub Action and written to public/config.json
 */
interface Config {
  branding: BrandingConfig;
  product: ProductConfig;
  tiers: TierConfig[];
  apiUrl: string;                     // "https://preview-{userId}-api.workers.dev"
  clerkPublishableKey: string;        // Clerk auth public key
}

/**
 * Context value with loading/error states
 */
interface ConfigContextValue {
  config: Config | null;
  loading: boolean;
  error: string | null;
}

// ============================================================================
// CONTEXT CREATION
// ============================================================================

const ConfigContext = createContext<ConfigContextValue | undefined>(undefined);

// ============================================================================
// PROVIDER COMPONENT
// ============================================================================

/**
 * ConfigProvider - Fetches and provides config to entire app
 *
 * USAGE:
 * Wrap your app in App.tsx:
 *
 * <ConfigProvider>
 *   <YourApp />
 * </ConfigProvider>
 *
 * HOW IT WORKS:
 * 1. On mount, fetches /config.json from public folder
 * 2. Parses JSON and stores in state
 * 3. Shows loading state while fetching
 * 4. Shows error if fetch fails (with fallback values)
 * 5. Provides config to all child components via Context
 */
export function ConfigProvider({ children }: { children: React.ReactNode }) {
  const [config, setConfig] = useState<Config | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    /**
     * Fetch config.json from public folder
     * GitHub Action writes this file during deployment
     */
    const fetchConfig = async () => {
      try {
        const response = await fetch('/config.json');

        if (!response.ok) {
          throw new Error(`Failed to load config: ${response.status}`);
        }

        const data: Config = await response.json();

        // Validate required fields
        if (!data.branding || !data.branding.appName) {
          throw new Error('Invalid config: missing branding.appName');
        }

        setConfig(data);
        setError(null);
      } catch (err) {
        console.error('Failed to load config:', err);
        setError(err instanceof Error ? err.message : 'Unknown error');

        // Fallback to default config for development
        // This allows local dev without config.json
        setConfig({
          branding: {
            appName: 'YourApp',
            primaryColor: '#0f172a',
            valueProp: 'Your Product Headline',
            description: 'Describe what your product does in one compelling sentence.',
          },
          product: {
            name: 'Your Product',
          },
          tiers: [],
          apiUrl: import.meta.env.VITE_API_URL || 'http://localhost:8787',
          clerkPublishableKey: import.meta.env.VITE_CLERK_PUBLISHABLE_KEY || '',
        });
      } finally {
        setLoading(false);
      }
    };

    fetchConfig();
  }, []);

  return (
    <ConfigContext.Provider value={{ config, loading, error }}>
      {children}
    </ConfigContext.Provider>
  );
}

// ============================================================================
// HOOK FOR CONSUMING CONFIG
// ============================================================================

/**
 * useConfig - Hook to access configuration in any component
 *
 * USAGE:
 *
 * function MyComponent() {
 *   const { config, loading, error } = useConfig();
 *
 *   if (loading) return <div>Loading...</div>;
 *   if (error) return <div>Error: {error}</div>;
 *
 *   return (
 *     <div>
 *       <h1>{config.branding.appName}</h1>
 *       <p>{config.branding.valueProp}</p>
 *     </div>
 *   );
 * }
 *
 * BENEFITS:
 * - No prop drilling
 * - Type-safe access to config
 * - Automatic loading/error handling
 * - Single source of truth
 *
 * @returns {ConfigContextValue} Config object with loading/error states
 * @throws {Error} If used outside ConfigProvider
 */
export function useConfig(): ConfigContextValue {
  const context = useContext(ConfigContext);

  if (context === undefined) {
    throw new Error('useConfig must be used within ConfigProvider');
  }

  return context;
}

/**
 * EXAMPLE: How GitHub Action generates config.json
 *
 * 1. Read from KV:
 *    - PREVIEW_{userId}:config:tiers
 *    - PREVIEW_{userId}:config:branding
 *    - PREVIEW_{userId}:tokens:clerk
 *
 * 2. Create Stripe products (get price IDs)
 *
 * 3. Generate config.json:
 *    {
 *      branding: { ...from KV... },
 *      product: { name: tierConfig.productName },
 *      tiers: [...with stripePriceIds...],
 *      apiUrl: `https://preview-${userId}-api.workers.dev`,
 *      clerkPublishableKey: clerkKeys.publishableKey
 *    }
 *
 * 4. Write to frontend/public/config.json
 *
 * 5. Deploy to Cloudflare Pages
 *
 * RESULT: App loads config and displays custom branding!
 */
