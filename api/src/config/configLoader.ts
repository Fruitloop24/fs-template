/**
 * ============================================================================
 * CONFIG LOADER - Dynamic Configuration from config.json
 * ============================================================================
 *
 * PURPOSE:
 * Loads tier configuration from config.json at runtime instead of hardcoding.
 * This allows the GitHub Action to inject custom tiers + Stripe price IDs
 * without modifying the Worker code.
 *
 * HOW IT WORKS:
 * 1. GitHub Action generates config.json with tiers from KV
 * 2. GitHub Action creates Stripe products (gets price IDs)
 * 3. GitHub Action writes config.json to api/src/config/config.json
 * 4. This file loads config.json and transforms it to Worker format
 * 5. All API endpoints use these tiers instead of hardcoded TIER_CONFIG
 *
 * CONFIG STRUCTURE (from GitHub Action):
 * {
 *   tiers: [
 *     {
 *       id: "free",
 *       name: "Free",
 *       price: 0,
 *       limit: 7,
 *       features: ["Basic access"],
 *       popular: false,
 *       stripePriceId: null
 *     },
 *     {
 *       id: "pro",
 *       name: "Pro",
 *       price: 29,
 *       limit: 100,
 *       features: ["Everything", "Priority support"],
 *       popular: true,
 *       stripePriceId: "price_1234abcd"
 *     }
 *   ]
 * }
 *
 * ============================================================================
 */

import { TierConfig } from '../types';

/**
 * Tier configuration from config.json (generated by GitHub Action)
 */
interface ConfigTier {
  id: string;
  name: string;
  price: number;
  limit: number | 'unlimited';
  features: string[];
  popular: boolean;
  stripePriceId: string | null;
}

interface Config {
  tiers: ConfigTier[];
  branding?: any;
  product?: any;
  apiUrl?: string;
  clerkPublishableKey?: string;
}

/**
 * Load configuration from config.json
 *
 * NOTE: This uses dynamic import() which works in Cloudflare Workers.
 * The config.json file is bundled with the Worker at deploy time.
 *
 * @returns {Promise<Config>} Configuration object
 */
async function loadConfig(): Promise<Config> {
  try {
    // Dynamic import of config.json
    // GitHub Action writes this file before deploying
    const config = await import('./config.json');
    return config.default || config;
  } catch (error) {
    console.error('Failed to load config.json:', error);

    // Fallback to default config for development
    // This allows local testing without config.json
    return {
      tiers: [
        {
          id: 'free',
          name: 'Free',
          price: 0,
          limit: 6,
          features: ['API access', 'Community support'],
          popular: false,
          stripePriceId: null,
        },
        {
          id: 'pro',
          name: 'Pro',
          price: 29,
          limit: 10,
          features: ['Everything in Free', 'Priority support'],
          popular: true,
          stripePriceId: null, // Will use env var for local dev
        },
        {
          id: 'developer',
          name: 'Developer',
          price: 50,
          limit: 'unlimited',
          features: ['Everything in Pro', 'Unlimited requests'],
          popular: false,
          stripePriceId: null, // Will use env var for local dev
        },
      ],
    };
  }
}

/**
 * Transform config tiers to TIER_CONFIG format
 *
 * Converts config.json format to the TierConfig format used by the Worker.
 *
 * @param {ConfigTier[]} tiers - Tiers from config.json
 * @returns {Record<string, TierConfig>} Tier configuration map
 */
function transformTiers(tiers: ConfigTier[]): Record<string, TierConfig> {
  const tierConfig: Record<string, TierConfig> = {};

  for (const tier of tiers) {
    tierConfig[tier.id] = {
      name: tier.name,
      price: tier.price,
      limit: tier.limit === 'unlimited' ? Infinity : tier.limit,
    };
  }

  return tierConfig;
}

/**
 * Get tier configuration
 *
 * This is the main export that replaces the old TIER_CONFIG.
 * Loads config.json and returns tier configuration.
 *
 * @returns {Promise<Record<string, TierConfig>>} Tier configuration
 */
export async function getTierConfig(): Promise<Record<string, TierConfig>> {
  const config = await loadConfig();
  return transformTiers(config.tiers);
}

/**
 * Get Stripe Price ID map
 *
 * Extracts stripePriceIds from config.json and creates the PRICE_ID_MAP format.
 * Falls back to environment variables if config doesn't have price IDs.
 *
 * @param {Env} env - Worker environment (for fallback to env vars)
 * @returns {Promise<Record<string, string>>} Map of tier ID to Stripe price ID
 */
export async function getPriceIdMap(env: any): Promise<Record<string, string>> {
  const config = await loadConfig();
  const priceIdMap: Record<string, string> = {};

  for (const tier of config.tiers) {
    if (tier.stripePriceId) {
      // Use price ID from config.json (generated by GitHub Action)
      priceIdMap[tier.id] = tier.stripePriceId;
    } else if (tier.id !== 'free') {
      // Fallback to environment variable for local dev
      const envKey = `STRIPE_PRICE_ID_${tier.id.toUpperCase()}`;
      priceIdMap[tier.id] = env[envKey] || '';
    }
  }

  return priceIdMap;
}

/**
 * Get all tiers (for API endpoint)
 *
 * Returns tiers in the format expected by the frontend /api/tiers endpoint.
 *
 * @returns {Promise<ConfigTier[]>} Array of tiers
 */
export async function getAllTiers(): Promise<ConfigTier[]> {
  const config = await loadConfig();
  return config.tiers;
}

/**
 * USAGE EXAMPLES:
 *
 * // Replace old TIER_CONFIG usage:
 * import { getTierConfig } from './config/configLoader';
 * const TIER_CONFIG = await getTierConfig();
 * const userLimit = TIER_CONFIG[plan].limit;
 *
 * // Replace old PRICE_ID_MAP usage:
 * import { getPriceIdMap } from './config/configLoader';
 * const priceIdMap = await getPriceIdMap(env);
 * const stripePriceId = priceIdMap[tier];
 *
 * // Get all tiers for /api/tiers endpoint:
 * import { getAllTiers } from './config/configLoader';
 * const tiers = await getAllTiers();
 * return Response.json({ tiers });
 */
